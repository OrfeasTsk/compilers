Project 3 compilers


Σκοπός αυτής της εργασίας είναι να παραχθεί μια ενδιάμεση αναπαράσταση (LLVM IR) για οποιοδήποτε πρόγραμμα minijava. Η εργασία αυτή αποτελεί συνέχεια της προηγούμενης κυρίως με την προσθήκη ενός ακόμα visitor με όνομα IRCreator ο οποίος υλοποιεί τις περισσότερες μεθόδους visit για την παραγωγή ενδιάμεσου κώδικα στους αντίστοιχους κόμβους χρησιμοποιώντας παράλληλα και μια σειρά απο βοηθητικές συναρτήσεις που αφορούν την αρχικοποίηση διαφόρων στοιχείων (IRInit, CounterInit) αλλά και αρκετές λειτουργίες ενός meta-προγράμματος για την παραγωγή ενδιάμεσου κώδικα όπως η emit για το γράψιμο στο .ll αρχείο, η newTempReg και newLabel για την απόκτηση μιας νέας προσωρινής μεταβλητής και ενός label αντίστοιχα με βάση τους αντίστοιχους counters και τέλος αρκετές συναρτήσεις οι οποίες παρέχουν κάποιο κοινό πρότυπο εκτύπωσης για τις εντολές της ενδιάμεσης γλώσσας που θα χρησιμοποιηθούν.
Σε πρώτη φάση, θα αναφερθούν οι αλλαγές που έγιναν στην προηγούμενη εργασία. Αρχικά, το όνομα της συνάρτησης που εκτυπώνει τα offsets άλλαξε από VTablePrint σε OffsetPrint (μιας και δεν ήταν σαφής η έννοια του VTable) και από πλευρά λειτουργικότητας εκτός από την εκτύπωση των offsets αποθηκεύονται και στις δομές για τις μεταβλητές (VarInfo) και τις συναρτήσεις (FunInfo) αντίστοιχα. Στην ειδική περίπτωση των συναρτήσεων που υπάρχει overriding οι συναρτήσεις που “επικαλύπτουν” παίρνουν το ίδιο offset με αυτές που επικαλύπτονται (ισχύει η μεταβατική ιδιότητα). Στη συνέχεια, θα αναλυθεί το αρχικό στάδιο της παραγωγής ενδιάμεσης γλώσσας που είναι κοινό για όλα τα προγράμματα minijava. Το στάδιο αυτό συναντάται στην IRInit και περιλαμβάνει την αρχικοποίηση της δομής VTable για κάθε κλάση του προγράμματος με την βοήθεια του symbol table. Μια από τις δύο σχετικές συναρτήσεις για την αρχικοποίηση της δομής VTable είναι η UniqueFunNames έτσι ώστε όλες οι συναρτήσεις στον ενδιάμεσο κώδικα να είναι ευδιάκριτες μεταξύ τους και άλλη είναι η VTableCreate όπου δημιουργείται ένα νέο VTable ή αντιγράφεται το VTable της γονικής κλάσης εισάγοντας τις νέες συναρτήσεις της κλάσης του minijava προγράμματος αντικαθιστώντας τις ήδη υπάρχουσες με το ίδιο όνομα (λόγω αντιγραφής απο την γονική κλάση). Έπειτα ακολουθούν οι σχετικές δηλώσεις και ορισμοί συναρτήσεων που είναι κοινές σε όλα τα προγράμματα που αφορούν την εκτύπωση, τον τερματισμό και το ειδικό exception για τα όρια του πίνακα.
Αφού λοιπόν κληθεί η IRInit στο global scope σειρά έχουν οι ορισμοί των συναρτήσεων του minijava προγράμματος. Αρχικά, γίνεται η επαναφορά όλων των counters για τους εικονικούς καταχωρητές και για τα labels. Ύστερα, αφού οριστεί το signature της συνάρτησης ακολουθεί η δέσμευση του αντίστοιχου χώρου στη στοίβα για όλες τις τοπικές μεταβλητές οι οποίες αρχικοποιούνται (zero-initialization) και για τα ορίσματα τα οποία παίρνουν τις αντίστοιχες τιμές. Στην ειδική περίπτωση της main το όρισμα args αγνοείται τελείως. 
Έπειτα, όσον αφορά τα expressions επιστρέφουν το όνομα του εικονικού καταχωρητή που άφησαν το αποτέλεσμα και τον τύπο του αποτελέσματος στην δομή RegInfo. Κάποια expressions που χρειάζονται μια ιδιαίτερη εξήγηση ακολουθούν στην συνέχεια. Στο NotExpression για την εύρεση του συμπληρώματος χρησιμοποιείται η πράξη xor με την μονάδα. Στο AllocationExpression δεσμεύεται χώρος για μια virtual δομή για το αντικείμενο που περιλαμβάνει όλα τα πεδία και έναν δείκτη στην αρχή του κατάλληλου VTable ανάλογα με την κλάση. Στο ArrayAllocationExpression δεσμεύεται χώρος για n + 1 ακεραίους, όπου n είναι το πραγματικό size του πίνακα ακεραίων, αλλά επειδή το size αυτό είναι χρήσιμο εισάγεται στην αρχή και έτσι ο δείκτης του πίνακα μετακινείται μια θέση δεξιά στον πρώτο ακέραιο. Στο ThisExpression επιστρέφεται το όνομα του ειδικού εικονικού καταχωρητή %this που αναφέρεται στο αντικείμενο και μπαίνει ως όρισμα σε κάθε συνάρτηση. Στις περιπτώσεις των literals επιστρέφεται η αντίστοιχη τιμή και δεν δημιουργείται κάποιος προσωρινός καταχωρητής (τα true και false αντιστοιχούν στις τιμές 1 και 0 αντίστοιχα). Όσον αφορά τις κλήσεις συναρτήσεων MessageSend πραγματοποιείται σε πρώτη φάση αναζήτηση στο VTable του αντικειμένου που την καλεί χρησιμοποιώντας το offset της συνάρτησης (με την χρήση i8* και μετά cast σε i8**) και στην συνέχεια γίνεται η κλήση με ορίσματα τους εικονικούς καταχωρητές που άφησαν το αποτέλεσμα τους τα κανονικά ορίσματα. Στο ArrayLength επιστρέφεται το μέγεθος του πίνακα που είχε αποθηκευτεί. Στο ArrayLookup επιστρέφεται η τιμή του στοιχείου στην ζητούμενη θέση σε αντίθεση με το ArrayAssignmentStatement που υπολογίζεται η διεύθυνση και έτσι υπάρχει διαχωρισμός ανάμεσα σε rvalue και lvalue αντίστοιχα, χωρίς την χρήση κάποιου flag από αυτόν τον γονιό που τις καλεί. Στις αριθμητικές πράξεις επιστρέφεται ο εικονικός καταχωρητής που περιλαμβάνει το αποτέλεσμα της αντίστοιχης πράξης και μόνο το AndExpression έχει μια πιο περίπλοκη λογική που η οποία πρώτα αποτιμά την πρώτη συνθήκη και αν δεν είναι αληθής απλά επιστρέφεται ο εικονικός καταχωρητής που “κρατά” αυτήν τη μη αληθής τιμή, αλλιώς το αποτέλεσμα εξαρτάται από την αποτίμηση της δεύτερης τιμής και όλα αυτά μέσω της εντολής phi δηλαδή με βάση τα basic blocks που έχει εισέλθει το control flow, μέσω των jumps υπό συνθήκη, ανάλογα με τις παραπάνω περιπτώσεις. 
Τέλος, η περιγραφή του visitor θα κλείσει με την επεξήγηση των statements. Στο PrintStatement απλά καλείται η δοσμένη συνάρτηση print_int. Στο WhileStatement ελέγχεται η συνθήκη σε κάθε επανάληψη και γίνεται jump σε ένα label πριν την συνθήκη ώστε να υπάρξει επανάληψη. Στο IfStatement απλά ελέγχεται η συνθήκη και η οποία οδηγεί το control flow είτε στο then αν αληθεύει είτε στο else αν δεν αληθεύει. Στα ArrayAssignmentStatement και AssignmentStatement απλά γίνεται store η τιμή της έκφρασης δεξιά από το “=” στη κατάλληλη θέση του πίνακα και στον χώρο που έχει δεσμευτεί (για το πεδίο ή την τοπική μεταβλητή) αντίστοιχα.


Γενικές παρατηρήσεις:


-  Για int χρησιμοποιήθηκε i32, για int[] χρησιμοποιήθηκε i32*, για αντικείμενα χρησιμοποιήθηκε i8* και για boolean χρησιμοποιήθηκε i8 (στην αρχή είχε χρησιμοποιηθεί i1 αλλά για περισσότερη σιγουριά μετά από ερώτηση στο piazza αλλάχτηκαν σε i8 και έτσι όποτε χρειάστηκε η τιμή τους σε κάποιο conditional branch χρησιμοποιήθηκε η trunc και στην ειδική περίπτωση του CompareExpression η zext ώστε να υπάρχει συμβατότητα με i8).
- Στις παρακάτω περιπτώσεις χρήσης πινάκων έγιναν οι εξής έλεγχοι. Στο ArrayAllocationExpression έγινε έλεγχος για μη αρνητικό index. Στο ArrayAssignmentStatement  και ArrayLookup έγινε έλεγχος για μη αρνητικό index και index μικρότερο του μεγέθους (με ult).
-  Όσον αφορά την ειδική περίπτωση των Identifiers ανάλογα με το αντικείμενο Info που δίνεται ως όρισμα είτε τοποθετείται σε αυτό το όνομα είτε γίνεται αναζήτηση της μεταβλητής σε κάποια κλάση ώς πεδίο ή σε κάποια συνάρτηση και επιστρέφεται η τιμή της είτε γίνεται αναζήτηση της μεταβλητής σε κάποια κλάση ώς πεδίο ή σε κάποια συνάρτηση και επιστρέφεται η διεύθυνσή της.
- Στις κλάσεις VarInfo, FunInfo και RegInfo προστέθηκε συνάρτηση για την επιστροφή των τύπων σε μορφή IR τύπων.
- Περισσότερες λεπτομέρειες υπάρχουν και στα σχόλια στα περισσότερα σημεία του κώδικα.
- Τα εργαλεία jtb και javacc πρέπει να έχουν μπεί στον αμέσως προηγούμενο κατάλογο από το Makefile.


Ορφέας Τσουράκης 1115201700175